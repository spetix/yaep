/**
 * JavaCC template file created by SF JavaCC plugin 1.5.17+ wizard for JavaCC 1.5.0+
 */options{
  JDK_VERSION = "1.7";
  STATIC = false;
  FORCE_LA_CHECK = true;
  DEBUG_PARSER = true;
  DEBUG_LOOKAHEAD = true;
  DEBUG_TOKEN_MANAGER = true;
  // this reduces parser performances overall, better find the right place for:
   LOOKAHEAD=5;}
PARSER_BEGIN(ExpressionParser)
package it.fe.cassano.yeap.ccparser;
import java.io.BufferedReader;
import java.io.Reader;
import it.fe.cassano.yeap.ast.*;
import it.fe.cassano.yeap.tokenizer.ITokenizer;
import it.fe.cassano.yeap.parser.IParser;
import java.util.List;
import java.util.Vector;
import it.fe.cassano.yeap.visitor.ExpType;

public class ExpressionParser implements ITokenizer, IParser{
  public boolean isValidExpression() 
  {
    boolean isValid = false;
    try
    {      isValid = testvalid();
    }
    catch (Exception e)
    {
      isValid = false;    }
  
    return isValid;  }     }PARSER_END(ExpressionParser)

SKIP :{  " "| "\r"| "\t"| "\n"}TOKEN : /* OPERATORS */{  < PLUS : "+" >| < MINUS : "-" >| < MUL : "*" >| < DIV : "/" >
| < ASSIGN : "=" >
}
TOKEN : /* SYNTAX HELPERS */
{  < COLON : ":" >
| < OBR: "(" >
| < CBR: ")" >
| <  COMMA: "," >}

TOKEN : /* IDENTIFIERS */
{
  < IDENT : (< ALPHA >|< UNDERSCORE >)(< ALPHA > |< UNDERSCORE > | < DIGIT > | < LOWCASE > )* >
| < #ALPHA : ["A"-"Z"] >
| < #UNDERSCORE : "_" >
}

TOKEN : /* FUNCTION NAME */
{
  < FNAME : < LOWCASE >(< ALPHA > | < DIGIT > | < LOWCASE >)* >
|  < #LOWCASE : ["a"-"z"] >}

TOKEN :
{//  < JFUN : < LOWCASE > ((< ALPHA >| < DIGIT > | < LOWCASE >)* | (< ALPHA >| < DIGIT > | < LOWCASE >)< DOT >)+(< ALPHA > | < DIGIT >| < LOWCASE >)+ >
 < JFUN : (< LOWCASE > (<ALPHA >|< DIGIT >|<LOWCASE >)*< DOT >)+< ALPHA >(< ALPHA >|< DIGIT >|< LOWCASE >|< UNDERSCORE >)*< DOT >(< ALPHA >|< LOWCASE >|< UNDERSCORE >)(< ALPHA >| < DIGIT > | < LOWCASE >)* >
}
TOKEN : /* NUMBERS */{  < INTNUM : < DIGIT >(< ZERO >| < DIGIT >)* | < ZERO > >| < #DIGIT : [ "1"-"9" ] >
| < #ZERO : "0" >}

TOKEN : /* REAL NUMBERS */
{
  < REALNUM : < INTNUM > < DOT > (< ZERO > | < DIGIT >)* >   
| < #DOT : "." >}

TOKEN : /* DATA TYPES */
{  < DATATYPE : "RealExp" | "NumExp" >
}

public Exp expr() :
{Token id,op=null; Exp t1, t2; }
{
  /* populate expression */
  (     t1=assignment()
    | 
    t1=fundef()
  ) (  < COMMA > t2=expr() { t1= new SeqExp(t1, t2); } )*  {    return t1;
  }
 |  t1=term()
 (   <PLUS > t2=term()  
  {
    t1=new PlusExp(t1,t2);
  }
 | < MINUS > t2=term() 
  {
    t1=new MinusExp(t1,t2);
  }
)*
	{	  return t1;
	}
}


Exp assignment() :
{Token id; Exp t1;}
{  	
    id=  < IDENT > < ASSIGN > t1=expr()    {
      t1 = new AssignExp(new IdentExp(id.image), t1);
      return t1;    }
}

Exp fundef():
{Token fLabel,fId,tId; List<ExpType> par = new Vector<ExpType>();}{	fLabel=< FNAME > <ASSIGN > fId=< JFUN ><OBR > fundefparams(par) < CBR ><COLON > tId= <DATATYPE > 	{  		return new FunDefineExp(new FunSignExp(fLabel.image,ExpType.valueof(tId.image),par), new FunCodeExp(fId.image,ExpType.valueof(tId.image),par));
	}}
  
void fundefparams(List<ExpType > params):
{ Token t; }
{
  t=< DATATYPE > {
    params.add(ExpType.valueof(t.image));
  }
  (  < COMMA > fundefparams(params))*
}





Exp term():
{Exp f1; Exp f2; }
{  f1=factor()
  (      < MUL > f2=factor() 
 {   f1= new ProductExp(f1,f2); }
| < DIV > f2=factor() 
 {
   f1= new DivideExp(f1,f2);
  }
)*
{
  return f1;}
}


Exp factor():
{ Token num; Token id; Exp fact; }
{
  num=<INTNUM> { return new NumExp(Integer.parseInt(num.image)); }
  |
  num= < REALNUM >  {    return new RealExp(Float.parseFloat(num.image));  }
  | 
  id= < IDENT >  {    return new IdentExp(id.image);
  }
  | 
  < OBR > fact=expr() < CBR > { return fact;}  |
  fact = function()  {
    return fact;  }
  |
  fact = unaryMinus()
  {
    return fact;  } }

Exp function():
{ Token fname; List<Exp > params = new Vector<Exp >(); }
{
  fname= < FNAME ><OBR ><CBR >
  {
    return new FunExp(fname.image,params);
  }
| 
  LOOKAHEAD(3) fname= < FNAME >< OBR > fparams(params) < CBR >
  {
    return new FunExp(fname.image,params);
  } 
}

void fparams(List<Exp > params):
{ Exp e1; }
{
  e1= expr()  {
    params.add(e1);
  }  ( LOOKAHEAD(2) < COMMA > fparams(params))*}

Exp unaryMinus():
{Exp e;}
{
  < MINUS > e = expr()
  {
    return new UnaryMinusExp(e);  }}




protected boolean testvalid() :
{}
{
  expr() < EOF >
  {
    return true;
  }
| < EOF >
  {
    return false;
  }   
}



/*
BNF:
// LEFT RECURSION IS PRESENT!
EXP ::= TERM
EXP ::= EXP + TERM 
EXP ::= EXP - TERM
EXP ::= ASSIGNMENT , EXP
TERM ::= FACTOR
TERM ::= TERM * FACTOR
TERM ::= TERM / FACTOR 
FACTOR ::= num | ( EXP ) | IDENT | FUNCTION

FUNCTION ::= FUNNAME(PARAMS)
PARAMS ::= PARAM

ASSIGNMENT ::= IDENT = EXP
FACTOR ::= IDENTVAL

EBNF:

 

EXP ::= TERM ( [+|-] TERM )* | ident = EXP
TERM ::= FACTOR ( [*|/] FACTOR )*
FACTOR ::= num | identval | LBR EXP RBR
*/

/*
 * GRAMMAR WITH NO ACTION:
 */

/*
void expr() :
{ }
{
  < IDENT > (assignment())+
| 
  term() ( [ <PLUS >|< MINUS >] term() )* 
}

void assignment() :
{}
{
    < ASSIGN > expr()
}

void term() :
{ }
{
  factor() ( [ <MUL >| < DIV >] factor() )?
}

void factor() :
{}
{
  < INTNUM > | < IDENT > |< OBR > expr() < CBR > | 
}
*/
