/**
 * JavaCC template file created by SF JavaCC plugin 1.5.17+ wizard for JavaCC 1.5.0+
 */options{
  JDK_VERSION = "1.7";
  STATIC = false;
  FORCE_LA_CHECK = true;
  DEBUG_PARSER = true;
  DEBUG_LOOKAHEAD = true;
  DEBUG_TOKEN_MANAGER = true;
 }
PARSER_BEGIN(ExpressionParser)
package it.fe.cassano.yeap.ccparser;
import java.io.BufferedReader;
import java.io.Reader;
import it.fe.cassano.yeap.ast.*;
import it.fe.cassano.yeap.tokenizer.ITokenizer;
import it.fe.cassano.yeap.parser.IParser;
import java.util.List;
import java.util.ArrayList;
import it.fe.cassano.yeap.visitors.ExpType;
import org.apache.commons.lang3.StringUtils;

public class ExpressionParser implements ITokenizer, IParser{}PARSER_END(ExpressionParser)

SKIP :
{
  " "
| "\t"
}
TOKEN : /* EOL */
{
 < EOL : ( "\r" | "\n" )+ >
}

TOKEN : /* OPERATORS */
{
  < PLUS : "+" >
| < MINUS : "-" >
| < MUL : "*" >
| < DIV : "/" >
| < ASSIGN : "=" >
}
TOKEN : /* SYNTAX HELPERS */
{
  < COLON : ":" >
| < OBR: "(" >
| < CBR: ")" >
| <  COMMA: "," >
| < DEF : "%" >
| < VAL : "$" >
}


TOKEN : /* IDENTIFIERS */
{
  < IDENT : (< ALPHA >|< UNDERSCORE >)(< ALPHA > |< UNDERSCORE > | < DIGIT > | < LOWCASE > )* >
| < #ALPHA : ["A"-"Z"] >
| < #UNDERSCORE : "_" >
}

TOKEN : /* IDENTVAL */
{
  < VALUEIDENT : < VAL ><IDENT > >
}

TOKEN : /* FUNCTION NAME */
{
  < FNAME : < LOWCASE >(< ALPHA > | < DIGIT > | < LOWCASE >)* >
|  < #LOWCASE : ["a"-"z"] >
}

TOKEN :
{
  < JFUN : (< LOWCASE > (<ALPHA >|< DIGIT >|<LOWCASE >)*< DOT >)+< ALPHA >(< ALPHA >|< DIGIT >|< LOWCASE >|< UNDERSCORE >)*< DOT >(< ALPHA >|< LOWCASE >|< UNDERSCORE >)(< ALPHA >| < DIGIT > | < LOWCASE >)* >
}

TOKEN : /* NUMBERS */
{
  < INTNUM : < DIGIT >(< ZERO >| < DIGIT >)* | < ZERO > >
| < #DIGIT : [ "1"-"9" ] >
| < #ZERO : "0" >
}

TOKEN : /* REAL NUMBERS */
{
  < REALNUM : < INTNUM > < DOT > (< ZERO > | < DIGIT >)* >   
| < #DOT : "." >
}

TOKEN : /* DATA TYPES */
{
  < DATATYPE : "RealExp" | "NumExp" >

}

/* VN */
public void lines():
{}
{
  (
    (
      fundef() /* | sequence() */
    ) < EOL >
  )+
}

/* Function alias definition */
Exp fundef():
{Token fAlias, javaName, returnType; List<ExpType > par = new ArrayList<ExpType >(); }
{
	 < DEF > fAlias=< FNAME > <ASSIGN > javaName=< JFUN ><OBR > fundefparams(par) < CBR ><COLON > returnType=<DATATYPE >
	 {	   	
  		return new FunDefineExp(new FunSignExp(fAlias.image,ExpType.valueof(returnType.image),par), new FunCodeExp(javaName.image,ExpType.valueof(returnType.image),par));	 }
}

void fundefparams(List<ExpType > params):
{Token t1;}
{
  t1=< DATATYPE >  {
    params.add(ExpType.valueof(t1.image));  }
  (  < COMMA > t1=<DATATYPE >  {	params.add(ExpType.valueof(t1.image));
  }
  )*
}

public void sequence():
{
}
{ 
  expr() (  < COMMA > expr())*
}



public Exp expr() :
{Exp t1,t2;Token t;}
{
  (    
 t1=assignment()
 |
 
 t1=term() (  (t=< PLUS >|t=< MINUS >) t2= term()
 {
   if (StringUtils.equals(t.image,"+"))
   {
     t1= new PlusExp(t1,t2);
   }
   else
   {	   t1 = new MinusExp(t1,t2);
   }
 }
)*
)
 {
   return t1;
 }
}


Exp assignment() :
{Exp t1; Token id;}
{  	
    id=< IDENT >  < ASSIGN > t1=expr()
    {		return new AssignExp(new IdentExp(id.image),t1);
    }
}


Exp term():
{Exp t1,t2;Token t;}
{
  (    
   t1=factor()  ( (t=< DIV >|t=< MUL >) t2=factor()  {
    if (StringUtils.equals(t.image,"/"))
    {
      t1 = new DivExp(t1,t2);
    }
    else
    {
      t1 = new MulExp(t1,t2);    }
   } )*
 )
{
  return t1;}
}


Exp factor():
{Token t; Exp t1;}
{
 (   
  t=<INTNUM>
  {
    t1= new NumExp(Integer.parseInt(t.image));  }
 
  |
  t=< REALNUM >
  {
    t1 = new RealExp(Double.parseDouble(t.image));  }
  | 
    t=< VALUEIDENT >
    {
      t1 = new IdentExp(StringUtils.substring(t.image,1));    }
  | 
  < OBR > t1=expr() < CBR >
  |
  t1=function()
  | 
  t1=unaryMinus()
)
{
  return t1;}
}


Exp function():
{Token t;List<Exp > params = new ArrayList<Exp >();}
{
  t=< FNAME >< OBR > fparams(params) < CBR >
  {
    return new FunExp(t.image,params);  }
}

void fparams(List<Exp > params):
{Exp t1;}
{
  t1=param()  {
    params.add(t1);  }
   ( < COMMA >  param()
   {
    params.add(t1);
  }
  )*
}

Exp param():
{Exp t1;}
{
  t1 =expr()
  {
    return t1;  }
}

Exp unaryMinus():
{Exp e;}
{
  < MINUS > e = expr()
  {
    return new UnaryMinusExp(e);
  }
}

