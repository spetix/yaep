/**
 * JavaCC template file created by SF JavaCC plugin 1.5.17+ wizard for JavaCC 1.5.0+
 */options{
  JDK_VERSION = "1.7";
  static = false;
  FORCE_LA_CHECK = true;
  DEBUG_PARSER = true;
  DEBUG_LOOKAHEAD = true;
  DEBUG_TOKEN_MANAGER = true;
  LOOKAHEAD=2;}
PARSER_BEGIN(ExpressionParser)
package it.fe.cassano.astvisassignsample.ccparser;
import java.io.BufferedReader;
import java.io.Reader;
import it.fe.cassano.astvisassignsample.ast.*;
import it.fe.cassano.astvisassignsample.tokenizer.ITokenizer;
import it.fe.cassano.astvisassignsample.parser.IParser;


public class ExpressionParser implements ITokenizer, IParser{
  public boolean isValidExpression() 
  {
    boolean isValid = false;
    try
    {      isValid = testvalid();
    }
    catch (Exception e)
    {
      isValid = false;    }
  
    return isValid;  }     }PARSER_END(ExpressionParser)

SKIP :{  " "| "\r"| "\t"| "\n"}TOKEN : /* OPERATORS */{  < PLUS : "+" >| < MINUS : "-" >| < MUL : "*" >| < DIV : "/" >
| < ASSIGN : "=" >
| < OBR: "(" >
| < CBR: ")" >
| <  COMMA: "," >}

TOKEN : /* IDENTIFIERS */
{
  < IDENT : < ALPHA >(< ALPHA > | < DIGIT > )* >
| < #ALPHA : ["A"-"Z"]|"_" >
}

TOKEN : /* FUNCTION NAME */
{
  < FNAME : < LOWCASE >(< ALPHA > | < DIGIT > | < LOWCASE >)* >
|  < #LOWCASE : ["a"-"z"] >}

TOKEN : /* NUMBERS */{  < INTNUM : (< MINUS >)? < DIGIT >(< ZERO >| < DIGIT >)* | < ZERO > >| < #DIGIT : [ "1"-"9" ] >
| < #ZERO : "0" >}

TOKEN : /* REAL NUMBERS */
{
  < REALNUM : < INTNUM > < DOT > (< ZERO > | < DIGIT >)* >
| < #DOT : "." >}




public Exp expr() :
{Token id,op=null; Exp t1, t2; }
{
  /* populate expression */
  t1=assignment() ( < COMMA > t2=expr() { t1= new SeqExp(t1, t2); } )*  {    return t1;
  }
 | t1=term() ( [ op=<PLUS >|op=< MINUS >] t2=term() 
  { t1 = (op.kind==PLUS)? new PlusExp(t1,t2):new MinusExp(t1,t2);  } )*
  {
    return t1;
  }
}


Exp assignment() :
{Token id; Exp t1;}
{
    id=< IDENT > < ASSIGN > t1=expr()    {
      t1 = new AssignExp(new IdentExp(id.image), t1);
      return t1;    }
    
}



Exp term():
{Exp f1; Exp f2; Token op=null;}
{  f1=factor() ( [ op=< MUL > | op=< DIV > ] f2=factor()   {
    f1=(op.kind==MUL)?new ProductExp(f1,f2):new DivideExp(f1,f2);  }
 )*
 {   return f1; }
}


Exp factor():
{ Token num; Token id; Exp nestedExp; Token fname;}
{
  num=<INTNUM> { return new NumExp(Integer.parseInt(num.image)); }
  |
  num= < REALNUM >  {    return new RealExp(Float.parseFloat(num.image));  }
  | 
  id= < IDENT >  {    return new IdentExp(id.image);
  }
  | 
  < OBR > nestedExp=expr() < CBR > { return nestedExp;}  |
  fname= < FNAME >< OBR > nestedExp=fparams() < CBR >  {
    return new FunExp(fname.image,nestedExp);  } }

Exp fparams():
{ Exp e1; Exp e2=null;}
{
  e1= expr() ( < COMMA > e2 = fparams())*
  {
    return (e2!=null)?(new ExpParams(e1, e2)):(new ExpParams(e1));  }}


protected boolean testvalid() :
{}
{
  expr() < EOF >
  {
    return true;
  }
| < EOF >
  {
    return false;
  }   
}

/*
BNF:
// LEFT RECURSION IS PRESENT!
EXP ::= TERM
EXP ::= EXP + TERM 
EXP ::= EXP - TERM
EXP ::= ASSIGNMENT , EXP
TERM ::= FACTOR
TERM ::= TERM * FACTOR
TERM ::= TERM / FACTOR 
FACTOR ::= num | ( EXP ) | IDENT | FUNCTION

FUNCTION ::= FUNNAME(PARAMS)
PARAMS ::= PARAM

ASSIGNMENT ::= IDENT = EXP
FACTOR ::= IDENTVAL

EBNF:

 

EXP ::= TERM ( [+|-] TERM )* | ident = EXP
TERM ::= FACTOR ( [*|/] FACTOR )*
FACTOR ::= num | identval | LBR EXP RBR
*/

/*
 * GRAMMAR WITH NO ACTION:
 */

/*
void expr() :
{ }
{
  < IDENT > (assignment())+
| 
  term() ( [ <PLUS >|< MINUS >] term() )* 
}

void assignment() :
{}
{
    < ASSIGN > expr()
}

void term() :
{ }
{
  factor() ( [ <MUL >| < DIV >] factor() )?
}

void factor() :
{}
{
  < INTNUM > | < IDENT > |< OBR > expr() < CBR > | 
}
*/
