/**
 * JavaCC template file created by SF JavaCC plugin 1.5.17+ wizard for JavaCC 1.5.0+
 */options{
  JDK_VERSION = "1.7";
  STATIC = false;
  FORCE_LA_CHECK = true;
  DEBUG_PARSER = true;
  DEBUG_LOOKAHEAD = true;
  DEBUG_TOKEN_MANAGER = true;
  }
PARSER_BEGIN(ExpressionParser)
package it.fe.cassano.yeap.ccparser;
import java.io.BufferedReader;
import java.io.Reader;
import it.fe.cassano.yeap.ast.*;
import it.fe.cassano.yeap.tokenizer.ITokenizer;
import it.fe.cassano.yeap.parser.IParser;
import java.util.List;
import java.util.Vector;
import it.fe.cassano.yeap.visitors.ExpType;

public class ExpressionParser implements ITokenizer, IParser{
  }PARSER_END(ExpressionParser)

SKIP :{  " "| "\t"
}
TOKEN : /* EOL */
{ < EOL : ( "\r" | "\n" )+ >}TOKEN : /* OPERATORS */{  < PLUS : "+" >| < MINUS : "-" >| < MUL : "*" >| < DIV : "/" >
| < ASSIGN : "=" >
}
TOKEN : /* SYNTAX HELPERS */
{  < COLON : ":" >
| < OBR: "(" >
| < CBR: ")" >
| <  COMMA: "," >
| < DEF : "%" >
| < VAL : "$" >}

TOKEN : /* IDENTIFIERS */
{
  < IDENT : (< ALPHA >|< UNDERSCORE >)(< ALPHA > |< UNDERSCORE > | < DIGIT > | < LOWCASE > )* >
| < #ALPHA : ["A"-"Z"] >
| < #UNDERSCORE : "_" >
}

TOKEN : /* IDENTVAL */
{
  < VALUEIDENT : < VAL ><IDENT > >}

TOKEN : /* FUNCTION NAME */
{
  < FNAME : < LOWCASE >(< ALPHA > | < DIGIT > | < LOWCASE >)* >
|  < #LOWCASE : ["a"-"z"] >}

TOKEN :
{  < JFUN : (< LOWCASE > (<ALPHA >|< DIGIT >|<LOWCASE >)*< DOT >)+< ALPHA >(< ALPHA >|< DIGIT >|< LOWCASE >|< UNDERSCORE >)*< DOT >(< ALPHA >|< LOWCASE >|< UNDERSCORE >)(< ALPHA >| < DIGIT > | < LOWCASE >)* >
}
TOKEN : /* NUMBERS */{  < INTNUM : < DIGIT >(< ZERO >| < DIGIT >)* | < ZERO > >| < #DIGIT : [ "1"-"9" ] >
| < #ZERO : "0" >}

TOKEN : /* REAL NUMBERS */
{
  < REALNUM : < INTNUM > < DOT > (< ZERO > | < DIGIT >)* >   
| < #DOT : "." >}

TOKEN : /* DATA TYPES */
{  < DATATYPE : "RealExp" | "NumExp" >

}

/*
public void lines():
{}
{  (    (      fundef() | sequence()
    ) < EOL >
  )+
}

public void sequence():
{}
{   expr() (  < COMMA > expr())*
}
*/

public void sequence()
{}
{
  ((fundef()|assignment())(< EOL >| < COMMA >))+ expr()}

public void expr() :
{}
{
 
 term() ( < PLUS > term() |< MINUS >  term() )*
 |
 assignment()
}


void assignment() :
{}
{  	
    < IDENT >  < ASSIGN > expr()
}

void fundef():
{}{	 < DEF > < FNAME > <ASSIGN > < JFUN ><OBR > fundefparams(par) < CBR ><COLON > <DATATYPE > }
  
void fundefparams():
{}
{
  < DATATYPE >
  (  < COMMA > <DATATYPE >)*
}




void term():
{}
{  factor() ( < DIV > factor() |< MUL >  factor() )*
}


void factor():
{}
{ 
  <INTNUM>
  |
  < REALNUM >
  | 
  < VALUEIDENT >
  | 
  < OBR > expr() < CBR >  |
  function()
  | 
  unaryMinus()}

void function():
{}
{
  < FNAME >< OBR > fparams() < CBR >
}

void fparams():
{ }
{
  param() ( < COMMA >  param())*}

void param():
{}
{  expr()
}

void unaryMinus():
{}
{
  < MINUS > expr()}


